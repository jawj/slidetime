// Generated by CoffeeScript 1.10.0
var b64, cls, get, make, text, xhr,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  hasProp = {}.hasOwnProperty;

b64 = function(input, output) {
  var chars, chr1, chr2, chr3, i, len;
  if (output == null) {
    output = '';
  }
  chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('');
  len = input.length;
  i = 0;
  while (i < len) {
    chr1 = input[i++];
    chr2 = input[i++];
    chr3 = input[i++];
    output += chars[chr1 >> 2];
    output += chars[((chr1 & 3) << 4) | (chr2 >> 4)];
    output += chars[((chr2 & 15) << 2) | (chr3 >> 6)];
    output += chars[chr3 & 63];
  }
  return output;
};

get = function(opts) {
  var el, els, hasCls, inside, ref, ref1, ref2, ref3, tag;
  if (opts == null) {
    opts = {};
  }
  inside = (ref = opts.inside) != null ? ref : document;
  tag = (ref1 = opts.tag) != null ? ref1 : '*';
  if (opts.id != null) {
    return inside.getElementById(opts.id);
  }
  hasCls = opts.cls != null;
  if (hasCls && tag === '*' && (inside.getElementsByClassName != null)) {
    return inside.getElementsByClassName(opts.cls);
  }
  els = inside.getElementsByTagName(tag);
  if (hasCls) {
    els = (function() {
      var j, len1, results;
      results = [];
      for (j = 0, len1 = els.length; j < len1; j++) {
        el = els[j];
        if (cls(el, {
          has: opts.cls
        })) {
          results.push(el);
        }
      }
      return results;
    })();
  }
  if ((opts.multi == null) && (ref2 = tag.toLowerCase(), indexOf.call(get.uniqueTags, ref2) >= 0)) {
    return (ref3 = els[0]) != null ? ref3 : null;
  } else {
    return els;
  }
};

get.uniqueTags = 'html body frameset head title base'.split(' ');

cls = function(el, opts) {
  var addClasses, c, classHash, classes, hasClasses, j, k, l, len1, len2, len3, len4, len5, m, o, p, ref, ref1, ref2, ref3, ref4, removeClasses, toggleClasses;
  if (opts == null) {
    opts = {};
  }
  classHash = {};
  classes = ((ref = el.className) != null ? ref : '').match(cls.re);
  if (classes != null) {
    for (j = 0, len1 = classes.length; j < len1; j++) {
      c = classes[j];
      classHash[c] = true;
    }
  }
  hasClasses = (ref1 = opts.has) != null ? ref1.match(cls.re) : void 0;
  if (hasClasses != null) {
    for (l = 0, len2 = hasClasses.length; l < len2; l++) {
      c = hasClasses[l];
      if (!classHash[c]) {
        return false;
      }
    }
    return true;
  }
  addClasses = (ref2 = opts.add) != null ? ref2.match(cls.re) : void 0;
  if (addClasses != null) {
    for (m = 0, len3 = addClasses.length; m < len3; m++) {
      c = addClasses[m];
      classHash[c] = true;
    }
  }
  removeClasses = (ref3 = opts.remove) != null ? ref3.match(cls.re) : void 0;
  if (removeClasses != null) {
    for (o = 0, len4 = removeClasses.length; o < len4; o++) {
      c = removeClasses[o];
      delete classHash[c];
    }
  }
  toggleClasses = (ref4 = opts.toggle) != null ? ref4.match(cls.re) : void 0;
  if (toggleClasses != null) {
    for (p = 0, len5 = toggleClasses.length; p < len5; p++) {
      c = toggleClasses[p];
      if (classHash[c]) {
        delete classHash[c];
      } else {
        classHash[c] = true;
      }
    }
  }
  el.className = ((function() {
    var results;
    results = [];
    for (k in classHash) {
      results.push(k);
    }
    return results;
  })()).join(' ');
  return null;
};

cls.re = /\S+/g;

make = function(opts) {
  var ak, av, c, j, k, len1, ref, sk, sv, t, v;
  if (opts == null) {
    opts = {};
  }
  t = document.createElement((ref = opts.tag) != null ? ref : 'div');
  for (k in opts) {
    if (!hasProp.call(opts, k)) continue;
    v = opts[k];
    switch (k) {
      case 'tag':
        continue;
      case 'parent':
        v.appendChild(t);
        break;
      case 'kids':
        for (j = 0, len1 = v.length; j < len1; j++) {
          c = v[j];
          if (c != null) {
            t.appendChild(c);
          }
        }
        break;
      case 'prevSib':
        v.parentNode.insertBefore(t, v.nextSibling);
        break;
      case 'text':
        t.appendChild(text(v));
        break;
      case 'cls':
        t.className = v;
        break;
      case 'style':
        for (sk in v) {
          sv = v[sk];
          t.style[sk] = sv;
        }
        break;
      case 'attrs':
        for (ak in v) {
          av = v[ak];
          t.setAttribute(ak, av);
        }
        break;
      default:
        t[k] = v;
    }
  }
  return t;
};

text = function(t) {
  return document.createTextNode('' + t);
};

xhr = function(opts) {
  var k, method, ref, ref1, req, v;
  if (opts == null) {
    opts = {};
  }
  method = (ref = opts.method) != null ? ref : 'GET';
  req = new XMLHttpRequest();
  req.onreadystatechange = function() {
    if (req.readyState === 4 && (req.status === 200 || !location.href.match(/^https?:/))) {
      return opts.success(req);
    }
  };
  if (opts.mime != null) {
    req.overrideMimeType(opts.mime);
  }
  if (opts.user != null) {
    req.user = opts.user;
  }
  if (opts.password != null) {
    req.password = opts.password;
  }
  if (opts.headers != null) {
    ref1 = opts.headers;
    for (k in ref1) {
      v = ref1[k];
      req.setRequestHeader(k, v);
    }
  }
  req.open(method, opts.url);
  if (opts.type === 'binString') {
    req.overrideMimeType('text/plain; charset=x-user-defined');
  } else if (opts.type != null) {
    req.responseType = opts.type;
  }
  req.send(opts.data);
  return true;
};

this.ParallelWaiter = (function() {
  function ParallelWaiter(waitingFor, cb) {
    this.waitingFor = waitingFor;
    this.cb = cb;
    this.returnValues = {};
  }

  ParallelWaiter.prototype.await = function(n) {
    if (n == null) {
      n = 1;
    }
    return this.waitingFor += n;
  };

  ParallelWaiter.prototype.done = function(returnValues) {
    var k, v;
    if (returnValues == null) {
      returnValues = {};
    }
    for (k in returnValues) {
      v = returnValues[k];
      this.returnValues[k] = v;
    }
    if (--this.waitingFor === 0) {
      return this.cb(this.returnValues);
    }
  };

  return ParallelWaiter;

})();

//# sourceMappingURL=affogato.js.map
