// Generated by CoffeeScript 1.10.0
var CanvasMovieMaker;

CanvasMovieMaker = (function() {
  CanvasMovieMaker.prototype.bytesPerClip = 50e6;

  function CanvasMovieMaker(canvas, context) {
    this.canvas = canvas;
    this.context = context;
    this.listeners = {};
    this.worker = new Worker('canvasmovieworker.js' + '?' + Math.random());
    this.worker.addEventListener('message', (function(_this) {
      return function(event) {
        var message;
        message = event.data;
        if (message.type === 'clip') {
          _this.clips.push(message.data);
          _this.files = [];
          return _this.callback();
        } else if (message.type === 'lastClip') {
          _this.clips.push(message.data);
          _this.files = [];
          return _this.encode2();
        } else {
          return _this.trigger(message.type, message.data);
        }
      };
    })(this));
  }

  CanvasMovieMaker.prototype.setSource = function(canvas, context, encSettings, soundData, timerSeconds) {
    var i, imageHeaderStr, j, ref, results;
    this.canvas = canvas;
    this.context = context;
    this.encSettings = encSettings;
    this.soundData = soundData;
    this.timerSeconds = timerSeconds;
    this.files = [];
    this.clips = [];
    this.frameCount = 0;
    this.clipFrameCount = 0;
    this.clipFrameBytes = 0;
    imageHeaderStr = "P7\nWIDTH " + this.canvas.width + "\nHEIGHT " + this.canvas.height + "\nDEPTH 4\nMAXVAL 255\nTUPLTYPE RGB_ALPHA\nENDHDR\n";
    this.imageHeader = new Uint8Array(imageHeaderStr.length);
    results = [];
    for (i = j = 0, ref = imageHeaderStr.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      results.push(this.imageHeader[i] = imageHeaderStr.charCodeAt(i));
    }
    return results;
  };

  CanvasMovieMaker.prototype.addEventListener = function(eventName, callbackFunc) {
    var base;
    if ((base = this.listeners)[eventName] == null) {
      base[eventName] = [];
    }
    this.listeners[eventName].push(callbackFunc);
    return this;
  };

  CanvasMovieMaker.prototype.on = CanvasMovieMaker.prototype.addEventListener;

  CanvasMovieMaker.prototype.trigger = function(eventName, arg) {
    var func, j, len, ref;
    ref = this.listeners[eventName] || [];
    for (j = 0, len = ref.length; j < len; j++) {
      func = ref[j];
      func(arg);
    }
    return this;
  };

  CanvasMovieMaker.prototype.addFrame = function(callback) {
    var canvasData, imageData, imageName;
    this.callback = callback;
    imageName = "frame_" + this.clipFrameCount + ".pam";
    canvasData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height).data;
    imageData = new Uint8Array(this.imageHeader.byteLength + canvasData.byteLength);
    imageData.set(this.imageHeader);
    imageData.set(canvasData, this.imageHeader.byteLength);
    this.addFile(imageName, imageData.buffer);
    this.frameCount++;
    this.clipFrameCount++;
    this.clipFrameBytes += imageData.byteLength;
    if (this.clipFrameBytes > this.bytesPerClip) {
      this.clipFrameCount = 0;
      this.clipFrameBytes = 0;
      this.encodeClip();
    } else {
      this.callback();
    }
    return this;
  };

  CanvasMovieMaker.prototype.addFile = function(fileName, fileBuffer) {
    this.files.push({
      name: fileName,
      data: fileBuffer
    });
    return this;
  };

  CanvasMovieMaker.prototype.encodeClip = function(returnType) {
    var args, file;
    if (returnType == null) {
      returnType = 'clip';
    }
    console.log("encoding up to frame " + this.frameCount);
    args = "-f image2 -c:v pam -r " + this.encSettings.inframerate + " -i frame_%d.pam -r " + this.encSettings.framerate + " " + this.encSettings.videocodec + " " + this.encSettings.format + " -y output.bin";
    this.worker.postMessage({
      type: 'command',
      returnType: returnType,
      "arguments": args.match(/\S+/g),
      files: this.files,
      memory: 64 * 1024 * 1024
    }, (function() {
      var j, len, ref, results;
      ref = this.files;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        file = ref[j];
        results.push(file.data);
      }
      return results;
    }).call(this));
    return this;
  };

  CanvasMovieMaker.prototype.encode = function() {
    if (this.clipFrameCount > 0) {
      return this.encodeClip('lastClip');
    } else {
      return this.encode2();
    }
  };

  CanvasMovieMaker.prototype.encode2 = function() {
    var args, clip, file, fileName, i, j, k, len, list, listArray, ref, ref1;
    list = '';
    ref = this.clips;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      clip = ref[i];
      fileName = "clip_" + i + ".bin";
      this.addFile(fileName, clip);
      list += "file '" + fileName + "'\n";
    }
    listArray = new Uint8Array(list.length);
    for (i = k = 0, ref1 = list.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
      listArray[i] = list.charCodeAt(i);
    }
    this.addFile('list.txt', listArray.buffer);
    if (this.soundData) {
      console.log('sound');
      this.addFile('sound.wav', this.soundData);
    }
    args = "-f concat -i list.txt ";
    if (this.soundData) {
      args += "-f wav -itsoffset " + (this.timerSeconds + this.encSettings.audiolag) + " -i sound.wav ";
    }
    args += "-c:v copy " + this.encSettings.audiocodec + " " + this.encSettings.format + " -y output.bin";
    this.worker.postMessage({
      type: 'command',
      returnType: 'done',
      "arguments": args.match(/\S+/g),
      files: this.files,
      memory: 128 * 1024 * 1024
    }, (function() {
      var l, len1, ref2, results;
      ref2 = this.files;
      results = [];
      for (l = 0, len1 = ref2.length; l < len1; l++) {
        file = ref2[l];
        results.push(file.data);
      }
      return results;
    }).call(this));
    return this;
  };

  return CanvasMovieMaker;

})();

//# sourceMappingURL=canvasmoviemaker.js.map
